var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/intro/",title:"Intro",description:"Intro to passkeys",content:""}),e.add({id:1,href:"/docs/intro/what-are-passkeys/",title:"What are passkeys?",description:"Passkeys are a replacement for passwords. A password is something that can be remembered and typed, and a passkey is a secret stored on one’s devices, unlocked with biometrics.",content:`Passkeys are:
Intuitive
Creating and using passkeys is as simple as consenting to save and use them. No having to create a password.
Automatically unique per-service
By design, passkeys are unique per-service. There’s no chance to reuse them.
Breach-resistant
A passkey is only stored on a user’s devices. RP servers store public keys. Even servers that assist in the syncing of passkeys across a user’s devices never have the ability to view or use the private keys for a user\u0026rsquo;s passkeys.
Phishing-resistant
Rather than trust being rooted in a human who has to verify they’re signing into the right website or app, browser, and operating systems enforce that passkeys are only ever used for the appropriate service.
The guidance on this site is currently targeted towards sites and services that are using either password only or password + OTP (SMS, app TOTP, app push, magic link) sign in flows. Future guidance will include more advanced and higher assurance scenarios.
`}),e.add({id:2,href:"/docs/use-cases/",title:"Use Cases",description:"Implement passkeys",content:""}),e.add({id:3,href:"/docs/use-cases/bootstrapping/",title:"Bootstrapping",description:"Bootstrapping an account on the web",content:`Authenticating the user #This section applies when the Relying Party (RP) does not yet know who is controlling the client device. There is no browser artifact (such as a cookie or a credential ID in local storage) available to the RP, although for now we assume that the user has an existing account with the RP.
To bootstrap an account, serve the user a sign-in page.
Start off by asking the user for their account identifier, typically a username or email address:
To support the autofill UI for passkeys, make sure to:
Add the username and webauthn value to any existing autocomplete annotations on the username input field as shown below in the example.
\u0026lt;div\u0026gt; \u0026lt;label for=\u0026quot;username\u0026quot;\u0026gt;Username:\u0026lt;/label\u0026gt; \u0026lt;input name=\u0026quot;username\u0026quot; id=\u0026quot;loginform.username\u0026quot; autocomplete=\u0026quot;username webauthn\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; On page load, check to see if autofill UI (conditional mediation) is available using an if statement, then call navigator.credentials.get() with mediation: \u0026quot;conditional\u0026quot; and userVerification: \u0026quot;preferred\u0026quot;.
\u0026lt;script\u0026gt; (async () =\u0026gt; { if ( typeof window.PublicKeyCredential !== 'undefined' \u0026amp;\u0026amp; typeof window.PublicKeyCredential.isConditionalMediationAvailable === 'function' ) { const available = await PublicKeyCredential.isConditionalMediationAvailable(); if (available) { // Query your server for options for \`navigator.credentials.get()\` try { const authOptions = await getAuthenticationOptions(); // This call to \`navigator.credentials.get()\` is \u0026quot;set and forget.\u0026quot; // The Promise will only resolve if the user successfully interacts // with the browser's autofill UI to select a passkey. const autoFillResponse = await navigator.credentials.get({ mediation: \u0026quot;conditional\u0026quot;, publicKey: { ...authOptions, // see note about userVerification below userVerification: \u0026quot;preferred\u0026quot;, } }); // Send the response to your server for verification. // Authenticate the user if the response is valid. await verifyAutoFillResponse(autoFillResponse); } catch (err) { console.error('Error with conditional UI:', err); } } } })(); \u0026lt;/script\u0026gt; This will cause the following to happen:
When the user interacts with the username field, the browser and platform will check whether a passkey exists in the platform authenticator that can be used with the relying party. If this is the case, the passkey will be presented to the user as an option to choose (along with other credentials that can be auto-filled, such as usernames stored in the browser’s password manager). The browser/platform might render a UI similar to the one shown below, although the exact look and feel will vary from platform to platform (Windows vs. Android vs. iOS), and from form factor to form factor (desktop vs. mobile): If the user selects the passkey, the platform UI will guide the user through a (often biometrics-based) user verification check.
If the user successfully passes the user verification, the navigator.credentials.get() succeeds and returns a WebAuthn response.
If the user selects a credential other than a passkey, the browser/platform chooses a different appropriate action (such as auto-filling the username), and the navigator.credentials.get() call does not resolve.
If the user selects the \u0026ldquo;Passkey from another device\u0026rdquo; option (NOTE: the exact text will vary slightly by platform), then the browser/platform will guide the user through using a FIDO2 security key or the Cross-Device Authentication (CDA) flow to use a passkey from their smartphone or tablet to deliver a WebAuthn response to the navigator.credentials.get() call.
This is why this is called the Conditional UI (or more commonly, the autofill UI) mode of WebAuthn — the platform authenticator UI that guides the user through the verification, or through using their phone, is only shown if the user has a passkey on this device (or chooses the \u0026ldquo;another device\u0026rdquo; option).
As we can see, in this mode the navigator.credentials.get() call either succeeds, or it doesn’t (never resolves). If it does succeed, then the result of the call will reveal both a user id, as well as a signed WebAuthn assertion, which the relying party will use to authenticate the user.
If the call doesn’t succeed, perform a \u0026ldquo;legacy\u0026rdquo; user authentication: you’ll get a username from this first page, and you then serve appropriate further login challenges (such as passwords, responding to SMS challenges, etc.) to the user in subsequent pages. These may include \u0026ldquo;account recovery\u0026rdquo; steps in case the user has forgotten their password or is otherwise not able to pass the regular login challenges. Once the user has passed all the login challenges, they’re considered authenticated and signed in.
What happens when the user doesn’t already have an account with the relying party? Usually, you will give users the option on the sign-in page to create an account. If the user chooses that option, collect the necessary information from the user to open a new account. If the user successfully opens a new account, they’re also considered authenticated and signed-in.
Once the user is signed in, it might be time to set up a new passkey for them. Do this for any of the following cases:
The user bootstrapped their account on the device by passing non-passkey login challenges (such as using a password). The user just created a new account at the relying party, and is considered signed-in because of that. The user was using a passkey, but they used a different device than the one they’re currently on (by selecting the \u0026ldquo;other device\u0026rdquo; shown in the example above). This can be checked by inspecting the authenticatorAttachment attribute in the returned PublicKeyCredential object. A note about user verification #This guidance sets userVerification to preferred, meaning that user verification will be attempted when possible.
Some devices, such as desktops and older laptops, may not have biometric sensors. On these devices, the user may be asked to enter their system login password for each sign in using a passkey if userVerification is set to required. This can be a very frustrating user experience to repeat over and over.
When preferred is used, some platform authenticators will always require a user verification check when the device has biometric sensors, but may skip user verification on devices without them.
The user verification result (conveyed in authenticator data flags) will reflect the actual user verification result and should always be validated against your requirements on the server.
Opting the user into passkeys #First, ensure that the user\u0026rsquo;s device and OS combo supports passkeys by calling:
PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable() If passkeys are supported, this will return true. If they aren\u0026rsquo;t supported, this will return false and you should abort the passkey enrollment flow.
Serve an opt-in or \u0026ldquo;upsell\u0026rdquo; modal/interstitial or page to the user offering them to create a passkey:
If the user has signed in with a passkey from another device (such as a phone, tablet, or FIDO2 security key), you might adjust the wording accordingly:
Consider showing (or linking to) longer descriptions explaining that all users that are able to unlock the current device will be able to access the account at the relying party to ensure that the user is giving fully informed consent.
If the user consents, call navigator.credentials.create(), making sure to ask for a platform authenticator, user verification preferred, discoverable credentials (formerly known as \u0026ldquo;resident keys\u0026rdquo;), and passing an exclude list of existing passkeys for the account:
navigator.credentials.create({ publicKey: { rp: { ...}, user: { ...}, challenge: ..., pubKeyCredParams: [ { \u0026quot;type\u0026quot;: \u0026quot;public-key\u0026quot;, \u0026quot;alg\u0026quot;: -7 // EC P256 }, { \u0026quot;type\u0026quot;: \u0026quot;public-key\u0026quot;, \u0026quot;alg\u0026quot;: -257 // RSA } ], excludeCredentials: [ { // other passkeys (i.e., credentials) tied to the user account type: \u0026quot;public-key\u0026quot;, id: new UInt8Array([21, 31, 56, ...]).buffer, }, { type: \u0026quot;public-key\u0026quot;, id: new UInt8Array([21, 31, 56, ...]).buffer, }, { ... } ], authenticatorSelection: { residentKey: \u0026quot;required\u0026quot;, userVerification: \u0026quot;preferred\u0026quot; }, } }) A note on attestation: We recommend that most relying parties not specify the attestation conveyance parameter attestation (thus defaulting to none), or instead explicitly use the value indirect. This guarantees the most streamlined user experience (platforms are likely to obtain consent from the user for other types of attestation conveyances, which likely results in a larger fraction of unsuccessful credential creations due to users canceling the creation).
When the WebAuthn call resolves, send the response to your server and associate the returned public key and credential ID with the user account.
`}),e.add({id:4,href:"/docs/use-cases/reauth/",title:"Reauthentication",description:"Performing a reauthentication with passkeys",content:`Reauthentication might happen for the following reasons:
The user signed out and now wants to sign in again The user session expired due to inactivity, and the user wants to sign in again The user is about to perform a sensitive action, and needs to re-confirm control over the user session You’ll use passkeys that you set up in the previous section to reauthenticate the user in each of these situations. The WebAuthn API call is the same in all three cases, but the UI treatment that you provide is slightly different. Since the particular account is specified by you, the platform will not offer the user to select a different account on your service.
Sensitive Actions #Let’s look at the UI for the last case first: when it’s time to re-authenticate for a sensitive action, check whether you have a credential ID for at least one passkey for the user.
If no such credential ID is available, serve a traditional login challenge suitable for reauthentication, for example:
We recommend that on this login challenge page, users can’t change their account identifier. Also, the login challenge should be something that an unauthorized user of the device can’t pass.
If, however, you do find at least one passkey credential ID for the user, then you can use passkeys for reauthentication:
When the user is ready (in the above example, when they click on the \u0026ldquo;Go\u0026rdquo; button), call navigator.credentials.get(), passing in all the user’s passkey credential IDs:
navigator.credentials.get({ publicKey: { challenge: ..., rpId: ..., allowCredentials: [{ type: \u0026quot;public-key\u0026quot;, id: new UInt8Array([21, 31, 56, ...]).buffer, }, { type: \u0026quot;public-key\u0026quot;, id: new UInt8Array([21, 31, 56, ...]).buffer, }, { ... }], // see note below userVerification: \u0026quot;preferred\u0026quot;, } }); NOTE: Be sure to read the guidance around userVerification from the previous page
If the user instead clicks on \u0026ldquo;Try another way\u0026rdquo;, you should offer them other sign in methods (password, etc.) to reauthenticate them (assuming the user has such other sign in methods available to them).
Expired Sessions and Logout #Now let’s look at the case where the reauthentication is triggered because the user logged themselves out, or the relying party expired the user\u0026rsquo;s session. To facilitate this, the relying party would have to keep some form of user session state reminding them of the account that used to be signed in, even when they consider the user signed-out (this could be achieved using browser artifacts such as cookies or local storage).
Note that a relying party may choose to treat signing-out as a comprehensive action and thus delete all references to the user’s identity. Such a relying party ought to treat a subsequent sign-in like an account bootstrap, and repeat the steps explained above.
You, as the relying party, might then serve a sign-in page like this:
If the user clicks on \u0026ldquo;Use a different account\u0026rdquo;, then you should enter an account bootstrap flow as explained on the previous page, repeating the steps in Bootstrapping an account, where the platform will let them select which account they want to use.
In this case, you should also give the user the ability to completely remove the suggested account from being listed on the sign-in page.
But if the user clicks the \u0026ldquo;Sign in as\u0026rdquo; button, check whether you have at least one passkey credential ID associated with the user. If no credential ID is available, serve a traditional login challenge suitable for reauthentication, for example:
If, however, you do find at least one passkey credential ID for the user, then you can use passkeys for reauthentication:
When the user is ready (in the above example, when they click on the “Go!” button), call navigator.credentials.get(), exactly as shown above (i.e., by passing in all the user’s passkey credential IDs).
If the user instead clicks on \u0026ldquo;Try another way\u0026rdquo;, you should offer them other sign in methods (password, etc.) to reauthenticate them.
`}),e.add({id:5,href:"/docs/tools-libraries/",title:"Tools \u0026 Libraries",description:"Prologue Doks.",content:""}),e.add({id:6,href:"/docs/tools-libraries/libraries/",title:"Libraries",description:"A list of libraries for passkeys and FIDO2/WebAuthn",content:`Updated for passkeys #Rust #webauthn_rs: WebAuthn for Rust Server Applications (William Brown) TypeScript #SimpleWebAuthn (Matthew Miller) Other FIDO2/WebAuthn libraries #The \u0026ldquo;Awesome WebAuthn\u0026rdquo; GitHub repo is also regularly updated with libraries from the community.
.NET #FIDO2 .NET Library (Anders Åberg, Alex Seigler) Go #Go WebAuthn Library (Duo Labs) Java #WebAuthn4J (Yoshikazu Nojima) Python #py_webauthn (Duo Labs) Ruby #webauthn-ruby (Cedarcode) `}),e.add({id:7,href:"/docs/tools-libraries/test-sites/",title:"Test \u0026 Demo Sites",description:`Updated for passkeys #WebAuthn.io passkeys.io Other FIDO2/WebAuthn Tools and Demos #Basic #Yubico Demo Site WebAuthn.me Advanced #aka.ms/webauthntest lbuchs/WebAuthn WebAuthn Response Debugger The \u0026ldquo;Awesome WebAuthn\u0026rdquo; GitHub repo is also regularly updated with tools and demos from the community.`,content:`Updated for passkeys #WebAuthn.io passkeys.io Other FIDO2/WebAuthn Tools and Demos #Basic #Yubico Demo Site WebAuthn.me Advanced #aka.ms/webauthntest lbuchs/WebAuthn WebAuthn Response Debugger The \u0026ldquo;Awesome WebAuthn\u0026rdquo; GitHub repo is also regularly updated with tools and demos from the community.
`}),e.add({id:8,href:"/docs/reference/",title:"Reference",description:"Help Doks.",content:""}),e.add({id:9,href:"/docs/reference/android/",title:"Android",description:"Resources for passkeys in Android",content:` Local Authenticator (create and use passkeys from the local device)
Supported External Authenticator (create and use passkeys from another device)
Planned Overview #The platform authenticator in Android 9+ has the following capabilities:
creating and using passkeys that are backed up to Google Password Manager using a passkey from the local Android device to sign into services on another device (such as a laptop or desktop), using FIDO Cross-Device Authentication Platform Notes #The Device Public Key (DPK) extension is supported in beta, but is currently gated behind a flag in Chrome. Developers can enable chrome://flags/#enable-experimental-web-platform-features to experiment with DPK on Android, or on desktop Chrome when using Cross-Device Authentication with an Android device. Resources #Security of Passkeys in the Google Password Manager Beta announcement FIDO2 API for Android Sample app `}),e.add({id:10,href:"/docs/reference/chromeos/",title:"Chrome OS",description:"Resources for passkeys in Google's Chrome OS",content:` Local Authenticator (create and use passkeys from the local device)
Planned External Authenticator (create and use passkeys from another device)
Supported Overview #Creation of passkeys in Chrome OS is not currently supported.
Passkeys from iOS and iPadOS can be used to sign in to web services using FIDO Cross-Device Authentication.
Platform Notes #Coming Soon
Resources #Coming Soon
`}),e.add({id:11,href:"/docs/reference/ios/",title:"iOS \u0026 iPadOS",description:"Resources for passkeys in Apple's iOS and iPadOS",content:` Local Authenticator (create and use passkeys from the local device)
Supported External Authenticator (create and use passkeys from another device)
Supported Overview #The platform authenticators in iOS 16+ and iPadOS 16+ have the following capabilities:
creating and using passkeys that are backed up to iCloud Keychain creating and using passkeys on/from another device, such as: an iPhone or iPad signed in to a different iCloud account an Android phone or tablet a FIDO2 security key1 1 On iOS and iPadOS, user verification methods (device PIN, biometric, etc) must already be configured on the security key prior to credential creation
Platform Notes #WebAuthn credentials created using the platform authenticator in iOS/iPadOS 15 and earlier will not not be converted to passkeys but will remain available for the lifetime of the device.
To replace a legacy platform credential with a passkey, start a credential registration ceremony and pass the same user handle (user.id) in the request. iOS/iPadOS will overwrite the legacy credential with a new passkey that will be backed up to iCloud Keychain.
Resources #Apple landing page for passkeys About the security of passkeys Supporting passkeys Supporting single-device passkeys on security keys Sample Code `}),e.add({id:12,href:"/docs/reference/macos/",title:"macOS",description:"Resources for passkeys in Apple macOS",content:` Local Authenticator (create and use passkeys from the local device)
Supported External Authenticator (create and use passkeys from another device)
Supported Overview #The platform authenticator in macOS Ventura (13) has the following capabilities:
creating and using passkeys that are backed up to iCloud Keychain creating and using passkeys on/from another device, such as: an iPhone or iPad signed in to a different iCloud account an Android device a FIDO2 security key1 1 On macOS, user verification methods (device PIN, biometric, etc) must already be configured on the security key prior to credential creation
Platform Notes #Legacy Credentials #WebAuthn credentials created using the platform authenticator in macOS Monterey (12) and earlier will not be converted to passkeys but will remain available for the lifetime of the device.
To replace a legacy platform credential with a passkey, start a credential registration ceremony and pass the same user handle (user.id) in the request. macOS will overwrite the legacy credential with a new passkey that will be backed up to iCloud Keychain.
Browser Behavior #Safari: credentials created in Safari are passkeys, are backed up to iCloud Keychain, and are available in other apps and services.
Chrome: credentials created by Chrome are currently single-device passkeys, are not backed up to iCloud Keychain, and are not available outside of Chrome.
Edge: credentials created by Edge are currently single-device passkeys, are not backed up to iCloud Keychain, and are not available outside of Edge.
Firefox: passkeys are not currently supported in Firefox on macOS. Single-device passkeys on a FIDO2 security key are supported. User verification is not supported, though, which makes it impossible to implement WebAuthn-based passwordless authentication at this time.
Resources #Apple landing page for passkeys About the security of passkeys Supporting passkeys Supporting single-device passkeys on security keys Sample Code `}),e.add({id:13,href:"/docs/reference/windows/",title:"Windows",description:"Resources for passkeys in Microsoft Windows",content:` Local Authenticator (create and use passkeys from the local device)
Planned External Authenticator (create and use passkeys from another device)
Partially Supported Overview #Windows Hello, the local platform authenticator in Windows 10 and 11, has the following capabilities:
creating and using single-device passkeys that are bound to the local device creating and using single-device passkeys on a FIDO2 security key The following is also possible in both Windows 10 and 11:
using passkeys from iOS and iPadOS devices in Chrome (108+) and Edge (108+) for signing in to web services using FIDO Cross-Device Authentication using passkeys from Android devices in Chrome (108+) and Edge (108+) for signing in to web services using FIDO Cross-Device Authentication Platform Notes #Coming Soon
Resources #Coming Soon
`}),e.add({id:14,href:"/docs/reference/terms/",title:"Terms",description:"A list of terms which are used frequently throughout this site and in discussions about passkeys, FIDO2, and WebAuthn.",content:`2FA user #A user whose account has 2FA turned on, i.e., who must present 2 authentication factors during sign-in.
2-Factor Authentication (2FA) #also sometimes referred to as MFA: multi-factor authentication or 2SV: two-step verification
This refers to a contract between a user and a Relying Party (RP) where the RP must collect at least two distinct authentication factors from the user during a bootstrap sign-in.
Account bootstrapping #A Relying Party (RP) authenticates a user without any prior knowledge of who the user is. This means that the RP not only has to verify the identity of the user (checking the password, verifying cryptographic signatures, etc), it also has to establish the identity of the user (figure out the user id, username, etc. of the user who’s signing in). This may happen when a user signs into an existing account for the first time on a newly-purchased device; or when a user logs into a website for the first time in a given browser instance. Or when a user logs into a website in a private browsing session. Or when a user signs into a mobile app for the first time on a given device (contrast this with reauthentication below).
Note that this is different from creating an account with a service in the first place.
Authentication factor #Information provided by a user (or one of the user’s devices) for purposes of authentication, usually in response to a login challenge. Often categorized into \u0026ldquo;knowledge factors\u0026rdquo; (e.g. passwords), \u0026ldquo;something you have\u0026rdquo; factors (e.g. another already signed-in device), and \u0026ldquo;something you are\u0026rdquo; factors (e.g. biometrics). Note that a single login challenge may collect multiple factors simultaneously.
Autofill UI #A privacy preserving list UI element that is rendered by the browser (or the OS platform in the case of native apps), in cooperation with the platform authenticator, on username and/or password fields that have the webauthn value included in the autocomplete attribute.
This UI element provides a list of passkeys that are available for the Relying Party (RP) on the local device, and may also provide an option to kick off Cross-Device Authentication (CDA) or use a FIDO2 security key.
A generic example of an autofill UI for passkeys is shown below:
The technical name for this feature in the WebAuthn and Credential Management specifications is \u0026ldquo;Conditional Mediation\u0026rdquo;.
WebAuthn Spec Reference Credential Management Spec Reference Cross-Device Authentication (CDA) #FIDO Cross-Device Authentication (CDA) allows a passkey from one device to be used to sign in on another device. For example, your phone can be linked to your laptop, allowing you to use a passkey from your phone to sign into a service on your laptop.
CDA is powered by the FIDO Client-to-Authenticator Protocol (CTAP) using \u0026ldquo;hybrid\u0026rdquo; transport. CTAP is implemented by authenticators and client platforms, not Relying Parties.
CDA Client #The client in a cross-device authentication flow is the device where the relying party is being actively accessed.
CDA Authenticator #The authenticator in a cross-device authentication flow is the device generating the FIDO assertion.
Conditional Mediation #See Autofill UI
Conditional UI #See Autofill UI
Device Public Key (DPK) #A Device Public Key (DPK) is a device-bound key that can be requested by a Relying Party (RP) for higher assurance scenarios where device continuity signals are desired. If supported by the authenticator, a signature from both the passkey and DPK are returned.
Example: Say that a sign-in request appears at a website along with some geolocation signal that has not been seen for this user account before, and is outside of the typical usage hours observed for the account. The risk may be deemed high enough not to allow the request, even with an assertion by a passkey on its own. But if a signature by a device-bound key that is well established for this user can also be presented, then that may tip the balance.
Just like a passkey, DPKs are unique to each RP.
Spec Reference (L3 Draft) Discoverable Credential #A Discoverable Credential (previously known as a \u0026ldquo;resident credential\u0026rdquo; or \u0026ldquo;resident key\u0026rdquo;) is a FIDO2/WebAuthn credential that is entirely stored in the authenticator (private key, credential ID, user handle, and other metadata). The Relying Party (RP) also stores a copy of the public key and credential ID
Passkeys (and single-device passkeys) are Discoverable Credentials.
Spec Reference Login challenge #A prompt served to the user that they need to satisfy.
Examples:
a prompt asking the user for their password a prompt asking the user to confirm sign-in on another device (e.g., their phone) a prompt asking the user to insert and activate their security key Account bootstrapping and reauthentication usually consist of serving the user one or more login challenges.
Logging in #see Signing in.
Passkey #sometimes referred to as a multi-device passkey
Short version:
A passkey is a FIDO2 Discoverable Credential that requires user verification and is protected against device loss.
Longer version:
A FIDO2/WebAuthn credential that can reliably be used for bootstrap sign-in, without requiring other login challenges such as passwords. \u0026ldquo;Reliable\u0026rdquo; here means that the passkey should be available to, and usable by, the user whenever they need to sign in. This availability can be achieved through different means: for example, platforms could restore passkeys from a backup whenever a user sets up a new device, offer passkeys across different contexts (a passkey established from an app can be used in the browser when visiting the app’s website), or allow users to exercise passkeys across devices (by, say, using the passkey from a nearby phone when signing in from a laptop).
The important thing is that a passkey is there when the user needs it, and that it can be used without other login challenges. A WebAuthn credential that was created in a private browsing context and disappears when that browsing context is dismissed would not be considered a passkey (since it won’t be there for the user next time they’re trying to sign in). Nor would a U2F credential on a security key (since it requires additional factors for sign-in).
Platform authenticator #A FIDO authenticator that is built-in to a user\u0026rsquo;s device.
Spec Reference Reauthentication #Reauthentication happens when a Relying Party (RP) already knows who the user is, but would like to reconfirm this.
For example, this can happen before making sensitive changes to an account (adding a recovery email address, changing authentication methods, etc.): a relying party would typically ask the user to re-enter their password or perform some other action to reconfirm their control of the session. Likewise, when a mobile app asks the user to sign in every time the app starts (or a web site asks the user to sign in again after a period of inactivity), this is technically a reauthentication, since the app or web site can choose to remember the user\u0026rsquo;s identity after the account has been bootstrapped on the device (using things like cookies or local storage).
Relying Party (RP) #The website that is trying to ascertain and verify the identity of the user or perform FIDO authentication.
Spec Reference Roaming authenticator #A FIDO authenticator usable with any device the user is trying to sign-in from. Roaming authenticators attach to users\u0026rsquo; devices in using USB, NFC, and/or Bluetooth. These authenticators are often referred to as \u0026ldquo;security keys\u0026rdquo;. A smartphone can also act as a roaming authenticator using FIDO Cross-Device Authentication.
Spec Reference Signing in #This can refer to either account bootstrapping or reauthentication.
Single-device passkey #A FIDO2 Discoverable Credential that requires user verification and is bound to a single authenticator. For example, FIDO2 security keys hold single-device passkeys as the credential cannot leave the device.
User Presence (UP) #A test of User Presence (UP) is used to ensure the user is in local proximity to the authenticator during an authentication or credential creation ceremony. UP is often satisfied by pressing a button or metallic area of a security key, or interacting with a platform authenticator on a device.
Spec Reference User Verification (UV) #User Verification (UV) requires the user to either perform a biometric gesture or enter the device PIN for the authenticator to authorize creation and use of the credential. In some cases, UV also satisfies a test of User Presence (such as when the authenticator itself has a biometric built-in or the device PIN is entered directly into the authenticator).
Spec Reference User-Verifying Roaming Authenticator #A User-Verifying Roaming Authentication (UVRA), also known as a first-factor roaming authenticator, can verify individual users through the use of biometrics, or through the user entering a device PIN. An important class of UVRAs are smartphones, in which case the “attachment” typically happens over a wireless connection.
Spec Reference `}),e.add({id:15,href:"/docs/reference/specs/",title:"Specifications",description:"List of specifications that enable passkeys",content:`The two primary technical specifications that work together to enable passkeys are Web Authentication, commonly referred to as WebAuthn, and the Client to Authenticator Protocol (CTAP), commonly referred to as FIDO2.
The two specs together are often referred to as one stack, FIDO2/WebAuthn.
W3C Web Authentication (WebAuthn) #WebAuthn is the primary specification used by developers.
Platforms also create their own platform-specific abstractions of the WebAuthn API for use by native apps.
Current Version: WebAuthn Level 2
Next Version: WebAuthn Level 3
Client to Authenticator Protocol (CTAP) #The FIDO Client to Authenticator Protocol, often referred to by its acronym CTAP, is responsible for communications with the authenticator over a number of transports including USB, NFC, and Bluetooth. Operating systems, and in some cases apps, utilize this protocol to pass requests from WebAuthn to the appropriate authenticator over its desired transport.
CTAP is implemented by authenticator and device vendors and abstracts away all of the complexity of interacting with authenticators from relying parties and developers.
Current Version: CTAP 2.1
Next Version: CTAP 2.2
The next version of CTAP is currently under development at the FIDO Alliance.
In the context of passkeys, CTAP 2.2 adds support for the hybrid transport, more commonly known as the FIDO Cross-Device Authentication flow, allowing a passkey to be used to sign in on another device (ex: passkey on Android signing into a service on Windows).
`}),e.add({id:16,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()